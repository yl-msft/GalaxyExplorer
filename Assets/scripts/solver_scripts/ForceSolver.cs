using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using GalaxyExplorer;
using Microsoft.MixedReality.Toolkit;
using Microsoft.MixedReality.Toolkit.Input;
using Microsoft.MixedReality.Toolkit.Input.UnityInput;
using Microsoft.MixedReality.Toolkit.UI;
using Microsoft.MixedReality.Toolkit.Utilities;
using Microsoft.MixedReality.Toolkit.Utilities.Solvers;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using Debug = UnityEngine.Debug;

[Serializable]
public class UnityForceSolverEvent : UnityEvent<ForceSolver>
{
}

public class ForceSolver : Solver, IMixedRealityFocusChangedHandler, IMixedRealityFocusHandler, IMixedRealityPointerHandler
{
    public enum State
    {
        None = 0,
        Root,
        Free,
        Dwell,
        Attraction,
        Manipulation,
    }

    private static int _dwellCounter;
    private static AudioSource _tractionBeamAudioSource;

    private ManipulationHandler _manipulationHandler;
    private Collider _attractionCollider;
    private Quaternion _rotationOffset, _previousRotation;
    private float _baseScale;
    private IAudioService _audioService;
    private AudioSource _activeAudioSource;
    private bool _forcePullToFrontOfCamera;
    private bool ForcePullToHandController => !_forcePullToFrontOfCamera;
    private Camera _mainCamera;
    private Coroutine _attractionDwellRoutine;
    private float _dwellTimer, _dwellForgivenessTimer;
    private readonly HashSet<IMixedRealityPointer> _focusers = new HashSet<IMixedRealityPointer>();
    private readonly HashSet<ForceTractorBeam> _activeTractorBeams = new HashSet<ForceTractorBeam>();
    private PlanetPreviewController planetController;
    private UiPreviewTarget previewTarget;

    // This should now be set through the GalaxyExplorerManager.ForcePullToCamFixedDistance property
    private float _offsetOnPullToCamera = 1f;

    public State ForceState { get; private set; }
    public State PreviousForceState { get; private set; }
    
    public bool EnableForce = true;
    [Range(0,10)]
    public float AttractionDwellDuration = 1f;

    public bool AvergeSides = true;
    public GameObject TractionBeamPrefab;
    public float AttractionDwellForgiveness = .5f;
    public Transform RootTransform;
    public ControllerTransformTracker ControllerTracker;
    public bool OffsetToObjectBoundsFromController = true;
    public ManipulationHandler ManipulationHandler;
    public Collider AttractionCollider;
    public float CurrentRelativeDwell => _dwellTimer;

    public UnityForceSolverEvent SetToRoot, SetToDwell, DwellCanceled, SetToAttract, SetToManipulate, SetToFree;

    protected override void Awake()
    {
        base.Awake();
        _mainCamera = Camera.main;

        _offsetOnPullToCamera = GalaxyExplorerManager.ForcePullToCamFixedDistance;

        _manipulationHandler = ManipulationHandler ? ManipulationHandler : GetComponentInChildren<ManipulationHandler>();
        Debug.Assert(_manipulationHandler != null, "Force Solver failed to find a manipulation handler");
        _attractionCollider = AttractionCollider ? AttractionCollider : GetComponentInChildren<Collider>();
        Debug.Assert(_attractionCollider != null, "Force Solver failed to find a attraction collider");

        _manipulationHandler.OnManipulationEnded.AddListener(OnManipulationEnd);

        if (ControllerTracker == null)
        {
            Debug.LogWarning(gameObject.name + " ForceSolver no controller tracker transform supplied will instantiate locally");
            var controllerTrackerObject = new GameObject(gameObject.name + " ForceSolver autogenerated controller tracker");
            ControllerTracker = controllerTrackerObject.AddComponent<ControllerTransformTracker>();
        }

        ControllerTracker.AllTrackingLost += OnControllersLost;
    }

    private void Start()
    {
        _audioService = MixedRealityToolkit.Instance.GetService<IAudioService>();
        StartRoot();
    }

    private void OnDestroy()
    {
        ControllerTracker.AllTrackingLost -= OnControllersLost;
    }

    private void UpdateGoalsAttraction()
    {
        // make sure has enough info
        if (ForcePullToHandController && _focusers.Count == 0)
        {
            // lost all focusers
            StartFree();
            return;
        }
        
        if (ForcePullToHandController)
        {
            GoalRotation = SolverHandler.TransformTarget.rotation * _rotationOffset;
            UpdateWorkingRotationToGoal();
            GoalScale = ControllerTracker.ResolvedTransform.localScale;
            GoalPosition = _focusers.Select(p => p.Controller.ControllerHandedness == Handedness.Left
                ? ControllerTracker.LeftSidePosition
                : ControllerTracker.RightSidePosition).Average();
        }
        else
        {
            var mainCameraTransform = _mainCamera.transform;
            GoalPosition = mainCameraTransform.position + mainCameraTransform.forward * _offsetOnPullToCamera;
        }
        
        if (ForcePullToHandController && OffsetToObjectBoundsFromController)
        {
            GoalPosition += GetOffsetPositionFromController();
        }
        UpdateWorkingPositionToGoal();

        if (IsAttractionComplete())
        {
            StartFree();
        }
    }

    private void UpdateTractionBeams()
    {
        switch (ForceState)
        {
            case State.Dwell:
                foreach (var tractorBeam in _activeTractorBeams)
                {
                    tractorBeam.Coverage = _dwellTimer / AttractionDwellDuration;
                }
                break;
            
            case State.Attraction:
                foreach (var tractorBeam in _activeTractorBeams)
                {
                    tractorBeam.Coverage = 1f;
                }
                break;
            
            case State.None:
            case State.Root:
            case State.Free:
            case State.Manipulation:
                break;
            
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private void SetActivePointersFocusLocked(bool locked)
    {
        foreach (var pointer in _focusers)
        {
            pointer.IsFocusLocked = locked;
        }
    }

    protected virtual bool IsAttractionComplete()
    {
        if (ForcePullToHandController)
        {
            return Vector3.Distance(GoalPosition, WorkingPosition) <= .05f;
        }
        else if (_forcePullToFrontOfCamera)
        {
            return Vector3.Distance(WorkingPosition, GoalPosition) <= 0.1f;
        }

        return false;
    }

    protected virtual Vector3 GetOffsetPositionFromController()
    {
        var controllerFwd = _focusers.Select(p => (p.Controller.ControllerHandedness == Handedness.Left
            ? ControllerTracker.LeftSideRotation
            : ControllerTracker.RightSideRotation) * Vector3.forward)
        .Average().normalized;
        
        var position = transform.position;
        var ray = new Ray(position - controllerFwd * 100, controllerFwd);
        var hit = _attractionCollider.Raycast(ray, out var hitInfo, 150);
        Debug.Assert(hit);
        return position - hitInfo.point;
    }

    private void StartRoot()
    {
        if (ForceState == State.Root)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Root;
        _manipulationHandler.enabled = false;
        SolverHandler.TransformOverride = RootTransform;
        OnStartRoot();
        SetToRoot?.Invoke(this);
    }

    protected virtual void OnStartRoot()
    {
    }

    private void StartDwell()
    {
        if (ForceState == State.Dwell)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Dwell;
        _manipulationHandler.enabled = false;
        SolverHandler.TransformOverride = ControllerTracker.ResolvedTransform;
        Debug.Assert(_attractionDwellRoutine == null);
        _attractionDwellRoutine = StartCoroutine(DwellCoroutine());
        OnStartDwell();
        SetToDwell?.Invoke(this);
    }

    protected virtual void OnStartDwell()
    {
    }

    public bool ForceSetDwellTimer(float time)
    {
        if (ForceState != State.Dwell)
        {
            return false;
        }
        _dwellTimer = time;
        return true;
    }

    private IEnumerator DwellCoroutine()
    {
        ++_dwellCounter;
        if (_dwellCounter == 1)
        {
            _audioService.PlayClip(AudioId.ForceDwell, out _tractionBeamAudioSource);
        }
        _dwellTimer = _activeTractorBeams.Count > 0 ? _activeTractorBeams.Max(tb => tb.Coverage) : 0f;
        _dwellForgivenessTimer = 0f;
        while (ForceState == State.Dwell &&
               _dwellTimer < AttractionDwellDuration &&
               EnableForce &&
               _dwellForgivenessTimer < AttractionDwellForgiveness)
        {
            _dwellTimer += Time.deltaTime;
            if (_focusers.Count == 0)
            {
                _dwellForgivenessTimer += Time.deltaTime;
            }
            else
            {
                _dwellForgivenessTimer = 0f;
            }
            yield return null;
        }

        --_dwellCounter;
        Debug.Assert(_dwellCounter >= 0);
        if (ForceState == State.Dwell &&
            _focusers.Count > 0 &&
            EnableForce &&
            _dwellForgivenessTimer < AttractionDwellForgiveness)
        {
            StartAttraction();
        }
        else
        {
            OnDwellCanceled();
        }
    }

    protected virtual void OnDwellCanceled()
    {
        if (_dwellCounter == 0)
        {
            _tractionBeamAudioSource.Stop();
            ReleaseAllTractorBeams();
        }
        _attractionDwellRoutine = null;
        DwellCanceled?.Invoke(this);
        if (ForceState == State.Dwell)
        {
            switch (PreviousForceState)
            {
                
                case State.Root:
                    StartRoot();
                    break;
                
                case State.Free:
                    StartFree();
                    break;
                
                case State.None:
                case State.Manipulation:
                case State.Attraction:
                case State.Dwell:
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    private void StartAttraction(bool forcePullToFrontOfCamera = false)
    {
        if (ForceState == State.Dwell)
        {
            _attractionDwellRoutine = null;
            SetActivePointersFocusLocked(true);
        }
        if (ForceState == State.Attraction)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Attraction;
        if (forcePullToFrontOfCamera)
        {
            _forcePullToFrontOfCamera = true;
            SolverHandler.TransformOverride = _mainCamera.transform;
        }
        else
        {
            _forcePullToFrontOfCamera = false;
            SolverHandler.TransformOverride = ControllerTracker.transform;
            SolverHandler.AdditionalOffset = Vector3.zero;
            var worldToPalmRotation = Quaternion.Inverse(SolverHandler.TransformTarget.rotation);
            _rotationOffset = worldToPalmRotation * transform.rotation;
        }
        _audioService.PlayClip(AudioId.ForcePull, out _activeAudioSource);
        OnStartAttraction();
        SetToAttract?.Invoke(this);
    }

    protected virtual void OnStartAttraction()
    {
    }

    private void StartManipulation()
    {
        if (ForceState == State.Manipulation)
        {
            return;
        }

        ReleaseAllTractorBeams();
//        SetActivePointersFocusLocked(false);
        PreviousForceState = ForceState;
        ForceState = State.Manipulation;
        SolverHandler.TransformOverride = ControllerTracker.transform;
        _manipulationHandler.enabled = true;
        _audioService.PlayClip(AudioId.ManipulationStart, out _activeAudioSource);
        OnStartManipulation();
        SetToManipulate?.Invoke(this);
    }

    protected virtual void OnStartManipulation()
    {
    }

    private void StartFree()
    {
        PreviousForceState = ForceState;
        ForceState = State.Free;
        SolverHandler.TransformOverride = ControllerTracker.transform;
        _manipulationHandler.enabled = false;
        if (_activeAudioSource != null)
        {
            _activeAudioSource.Stop();
        }
        _audioService.PlayClip(AudioId.ManipulationEnd, out _activeAudioSource, transform);
        SetActivePointersFocusLocked(false);
        OnStartFree();
        SetToFree?.Invoke(this);
    }

    protected virtual void OnStartFree()
    {
    }

    private void OnManipulationEnd(ManipulationEventData _)
    {
        StartFree();
    }

    private void OnControllersLost()
    {
        _focusers.Clear();
        switch (ForceState)
        {
            case State.Attraction:
                if (ForcePullToHandController)
                {
                    StartFree();
                }
                break;
            
            case State.Manipulation:
                StartFree();
                break;
            
            case State.None:
            case State.Root:
            case State.Free:
            case State.Dwell:
                break;
            
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private static bool TryToVerifyPointerAndController(IMixedRealityPointer pointer, out ShellHandRayPointer handRayPointer)
    {
        // verify that the pointer is a far pointer that inherits from the BaseControllerPointer so it is a MonoBehavior
        handRayPointer = pointer as ShellHandRayPointer;
        if (handRayPointer == null)
        {
            return false;
        }
        var controller = pointer.Controller;
        return controller != null &&
               !(false/*controller is WindowsMixedRealityGGVHand*/) &&
               (controller is IMixedRealityHand ||
               false/*controller is WindowsMixedRealityController*/)
            ;
    }

    private ForceTractorBeam AttachTractorBeamToPointer(ShellHandRayPointer pointer)
    {
        return ForceTractorBeam.AttachToHandRayPointer(pointer, TractionBeamPrefab);
    }

    private void ReleaseAllTractorBeams()
    {
        foreach (var tractorBeam in _activeTractorBeams)
        {
            tractorBeam.Dissipate();
        }
        _activeTractorBeams.Clear();
    }

    private static bool IsGgvOrDesktopController(IMixedRealityController controller)
    {
                return  false /*controller is WindowsMixedRealityGGVHand*/ ||
                        controller is MouseController
# if UNITY_EDITOR
//                        || controller is SimulatedArticulatedHand
#endif
                    ;
    }

    public override void SolverUpdate()
    {
        switch (ForceState)
        {
            case State.Root:
                SnapTo(RootTransform.position, RootTransform.rotation);
                break;
            
            case State.Dwell:
                if (PreviousForceState == State.Root)
                {
                    SnapTo(RootTransform.position, RootTransform.rotation);
                }
                UpdateTractionBeams();
                break;

            case State.Free:
                // do nothing
                break;

            case State.Attraction:
                UpdateGoalsAttraction();
                UpdateTractionBeams();
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnBeforeFocusChange(FocusEventData eventData)
    {
        if (!EnableForce || !TryToVerifyPointerAndController(eventData.Pointer, out var pointer))
        {
            return;
        }
        
        // this should never trigger!
        Debug.Assert(pointer != null);

        if (eventData.NewFocusedObject != null && eventData.NewFocusedObject.transform.IsChildOf(transform))
        {
            // if already listed then ignore
            if (!_focusers.Add(pointer))
            {
                return;
            }
            eventData.Pointer.FocusTarget = this;

            var isHoloLens2OrVr = !IsGgvOrDesktopController(eventData.Pointer.Controller);

            var tractorBeam = isHoloLens2OrVr ? AttachTractorBeamToPointer(pointer) : null;

            switch (ForceState)
            {
                case State.Root:
                case State.Free:
                    if (!IsGgvOrDesktopController(eventData.Pointer.Controller))
                    {
                        Debug.Assert(_activeTractorBeams.Add(tractorBeam));
                        StartDwell();
                    }

                    break;

                case State.Dwell:

                    if (isHoloLens2OrVr)
                    {
                        Debug.Assert(_activeTractorBeams.Add(tractorBeam));
                    }
                    break;
                    
                case State.Manipulation:
                case State.Attraction:
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        else
        {
            _focusers.Remove(pointer);
            if ((ForceSolver) eventData.Pointer.FocusTarget == this)
            {
                eventData.Pointer.FocusTarget = null;
            }
            _activeTractorBeams.Remove(ForceTractorBeam.GetTractorBeamFromPointer(pointer));
        }
    }

    public void OnFocusChanged(FocusEventData eventData)
    {
    }

    public virtual void OnFocusEnter(FocusEventData eventData)
    {
    }

    public virtual void OnFocusExit(FocusEventData eventData)
    {
    }

    public void OnPointerUp(MixedRealityPointerEventData eventData)
    {
        switch (ForceState)
        {
            // manipulation handler cares about pointer up, if the event was not used, it means it didnt receive it.
            case State.Manipulation:
                _manipulationHandler.OnPointerUp(eventData);
                break;
            
            case State.None:
            case State.Root:
            case State.Free:
            case State.Dwell:
            case State.Attraction:
                break;
                
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnPointerDown()
    {
        OnPointerDown(new MixedRealityPointerEventData(EventSystem.current));
    }

    public void OnPointerDown(MixedRealityPointerEventData eventData)
    {
        if (planetController == null)
        {
            planetController = FindObjectOfType<PlanetPreviewController>();
        }
        switch (ForceState)
        {
            case State.Root: 
                if (eventData.Pointer is IMixedRealityNearPointer)
                {
                    StartManipulation();
                    _manipulationHandler.OnPointerDown(eventData);
                } 
                else if (eventData.Pointer == null)
                {
                    if (planetController != null)
                    {
                        if (previewTarget == null)
                        {
                            previewTarget = GetComponentInChildren<UiPreviewTarget>();
                        }

                        if (previewTarget != null)
                        {
                            planetController.OnButtonSelected(previewTarget.slotId);
                        }
                    }
                    StartAttraction(true);
                }
                else
                {
                    StartAttraction(IsGgvOrDesktopController(eventData.Pointer.Controller));
                }
                break;
            
            case State.Dwell:
                    StartManipulation();
                    _manipulationHandler.OnPointerDown(eventData);
                break;

            case State.Attraction:
            case State.Free:
                StartManipulation();
                if (eventData.Pointer != null)
                {
                    _manipulationHandler.OnPointerDown(eventData);
                }
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnPointerClicked(MixedRealityPointerEventData eventData)
    {
    }

    public void OnPointerDragged(MixedRealityPointerEventData eventData)
    {
    }

    public void ResetToRoot()
    {
        StartRoot();
    }
}